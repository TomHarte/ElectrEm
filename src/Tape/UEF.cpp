#include "Internal.h"
#include "../HostMachine/HostMachine.h"

#define UEF_VERSION		0x000a

#define BAUDWISE_GAP	0x0112
#define FLOATING_GAP	0x0116
#define HTONE			0x0110
#define HTONEDUMMY		0x0111

#define PHASE_CHANGE	0x0115
#define BAUD_RATE		0x0113

#define IMPLICIT_DATA	0x0100
#define EXPLICIT_DATA	0x0102

#define SECURITY		0x0114
#define DEFINED_DATA	0x0104

#define MULTI_DATA1		0x0101
#define MULTI_DATA2		0x0103

/* the feeders */
class CUEFTapeChunk
{
	public:
		void Setup(CUEFChunkSelector * = NULL, float BaudRate = 0, Uint16 Phase = 0, bool Find32 = false);
		virtual ~CUEFTapeChunk();

		virtual bool Initialise();
		virtual Uint32 GetLength();
		virtual bool WriteEvents(TapeEventQueueUEF &) = 0;

		TapeEvent *NewEvent(TapeEventQueueUEF &, int Divider = 0);

		void CorrectTime(TapeEvent *);

	protected:
		Uint16 Phase;
		float BaudRate;

		Uint32 TotalTime;
		Uint32 TimeOffset, BitLengthFixed;
		CUEFChunk *DChunk8, *DChunk32;
		CUEFChunkSelector *sel;
};
CUEFTapeChunk::~CUEFTapeChunk()
{
	if(DChunk8) sel->ReleaseChunkPtr(DChunk8);
	if(DChunk32) sel->ReleaseChunkPtr(DChunk32);
}
void CUEFTapeChunk::Setup(CUEFChunkSelector *s, float BR, Uint16 Ph, bool Find32)
{
	BaudRate = BR;
	Phase = Ph;
	TimeOffset = TotalTime = 0;
	BitLengthFixed = (Uint32)((2000000.0f*65536.0f*16.0f) / BaudRate);

	sel = s;
	DChunk8 = sel->GetChunkPtr();

	if(Find32)
	{
		Uint32 Offset = sel->GetOffset();
		sel->Seek(1, SEEK_CUR);
		if(	(sel->CurrentChunk()->GetId() == MULTI_DATA1) ||
			(sel->CurrentChunk()->GetId() == MULTI_DATA2)
		)
			DChunk32 = sel->GetChunkPtr();
		else
		{
			DChunk32 = NULL;
			sel->Seek(Offset, SEEK_SET);
		}
	}
	else
		DChunk32 = NULL;
}
Uint32 CUEFTapeChunk::GetLength()
{
	return 0;
}
bool CUEFTapeChunk::Initialise() { return true; }
TapeEvent *CUEFTapeChunk::NewEvent(TapeEventQueueUEF &Target, int Divider)
{
	TapeEvent *Event;
	if(Event = Target.GetNewEvent())
	{
		Event->BaudRate = BaudRate;
		Event->Phase = Phase;

		Uint32 NewTime = TimeOffset + (BitLengthFixed >> Divider);
		Event->Length = ((NewTime >> 20) - (TimeOffset >> 20))&( (1 << 12)-1);
		TimeOffset += BitLengthFixed >> Divider;
		TotalTime += Event->Length;

		return Event;
	}

	return NULL;
}
void CUEFTapeChunk::CorrectTime(TapeEvent *Ev)
{
	/*

		As a result of integer underflow, it often happens that the
		'GetLength's return a value higher than the total length
		generated by 'WriteEvents' by 1.

		Chunks therefore call this function with their final event
		to fix that if it should occur

	*/
	Ev->Length += GetLength() - TotalTime;
}

/*

	GAP (&0116 and &0112)

*/
class CUEFTapeGap: public CUEFTapeChunk
{
	public:
		CUEFTapeGap(CUEFChunkSelector *a, float b, Uint16 c) { Setup(a, b, c); }
		Uint32 GetLength();
		bool Initialise();
		bool WriteEvents(TapeEventQueueUEF &);

	private:
		Uint32 Length;
};

bool CUEFTapeGap::Initialise()
{
	if(DChunk8->GetId() == BAUDWISE_GAP)
	{
		if(DChunk8->GetLength() < 2) return false;
		Uint16 Len = DChunk8->Get16();
		Length = (Uint32)((1000000.0f / BaudRate) * (float)Len);
	}
	else
	{
		if(DChunk8->GetLength() < 4) return false;
		Length = (Uint32)(DChunk8->GetFloat() * 2000000.0f);
	}

	return true;
}
Uint32 CUEFTapeGap::GetLength()
{
	return Length;
}
bool CUEFTapeGap::WriteEvents(TapeEventQueueUEF &Target)
{
	TapeEvent *NewEvent;
	if(NewEvent = Target.GetNewEvent())
	{
		NewEvent->Type = TE_GAP;
		NewEvent->BaudRate = BaudRate;
		NewEvent->Length = Length;
		NewEvent->Phase = Phase;
		return false;
	}

	return true;
}

/*

	HIGH TONE (&0110)

*/
class CUEFTapeHTone: public CUEFTapeChunk
{
	public:
		CUEFTapeHTone(CUEFChunkSelector *a, float b, Uint16 c) { Setup(a, b, c); }
		Uint32 GetLength();
		bool Initialise();
		bool WriteEvents(TapeEventQueueUEF &);

	private:
		Uint16 WaveCount;
};
bool CUEFTapeHTone::Initialise()
{
	if(DChunk8->GetLength() < 2) return false;
	WaveCount = DChunk8->Get16();
	return true;
}
Uint32 CUEFTapeHTone::GetLength()
{
	return (Uint32)((float)WaveCount*(1000000.0f / BaudRate));
}
bool CUEFTapeHTone::WriteEvents(TapeEventQueueUEF &Target)
{
	TapeEvent *Event = NULL;

	/* write bits as far as possible */
	Uint16 WCD = WaveCount >> 1;
	while(WCD--)
	{
		if(!(Event = NewEvent(Target)))
			return true;
		Event->Type = TE_BIT;
		Event->Data.Bit.Data32 = 0xf;
		Event->Data.Bit.Data8 = 1;
	}

	/* write an extra wave if necessary */
	if(WaveCount&1)
	{
		if(!(Event = NewEvent(Target, 1)))
			return true;
		Event->Type = TE_WAVE;
	}

	CorrectTime(Event);

	return false;
}

/*

	HIGH TONE + dummy (&0111)

*/
class CUEFTapeHToneDummy: public CUEFTapeChunk
{
	public:
		CUEFTapeHToneDummy(CUEFChunkSelector *a, float b, Uint16 c) { Setup(a, b, c); }
		Uint32 GetLength();
		bool Initialise();
		bool WriteEvents(TapeEventQueueUEF &);

	private:
		Uint16 WaveCount1, WaveCount2;
};
bool CUEFTapeHToneDummy::Initialise()
{
	if(DChunk8->GetLength() < 4) return false;
	WaveCount1 = DChunk8->Get16();
	WaveCount2 = DChunk8->Get16();
	return true;
}
Uint32 CUEFTapeHToneDummy::GetLength()
{
	return (Uint32)((float)(WaveCount1+WaveCount2+20)*(1000000.0f / BaudRate));
}
bool CUEFTapeHToneDummy::WriteEvents(TapeEventQueueUEF &Target)
{
	TapeEvent *Event;

	/*

	WaveCount1

	*/
		/* write bits as far as possible for WaveCount1 */
		Uint16 WCD = WaveCount1 >> 1;
		while(WCD--)
		{
			if(!(Event = NewEvent(Target)))
				return true;
			Event->Type = TE_BIT;
			Event->Data.Bit.Data32 = 0xf;
			Event->Data.Bit.Data8 = 1;
		}

		/* write an extra wave if necessary */
		if(WaveCount1&1)
		{
			if(!(Event = NewEvent(Target, 1)))
				return true;
			Event->Type = TE_WAVE;
		}

	/*

	Dummy

	*/
	Uint16 Code = 0x354;
	int c = 10;
	while(c--)
	{
		/* output bit */
		if(!(Event = NewEvent(Target)))
			return true;

		Event->Type = TE_BIT;
		Event->Data.Bit.Data32 = 0;
		Event->Data.Bit.Data8 = Code&1;
		Code >>= 1;
	}

	/*

	WaveCount2

	*/
		/* write bits as far as possible for WaveCount2 */
		WCD = WaveCount2 >> 1;
		while(WCD--)
		{
			if(!(Event = NewEvent(Target)))
				return true;
			Event->Type = TE_BIT;
			Event->Data.Bit.Data32 = 0xf;
			Event->Data.Bit.Data8 = 1;
		}

		/* write an extra wave if necessary */
		if(WaveCount2&1)
		{
			if(!(Event = NewEvent(Target, 1)))
				return true;
			Event->Type = TE_WAVE;
		}

	CorrectTime(Event);

	return false;
}

/*

	IMPLICIT DATA (&0100, possibly feat &0101/3)

*/
class CUEFTapeImplicitData: public CUEFTapeChunk
{
	public:
		CUEFTapeImplicitData(CUEFChunkSelector *a, float b, Uint16 c) { Setup(a, b, c, true); }
		Uint32 GetLength();
		bool WriteEvents(TapeEventQueueUEF &);
};
bool CUEFTapeImplicitData::WriteEvents(TapeEventQueueUEF &Target)
{
	TapeEvent *Event = NULL;

	while(!DChunk8->EOC())
	{
		Uint8 Data8;
		Uint32 Data32 = 0;

		Data8 = DChunk8->GetC();
		if(DChunk32) Data32 = DChunk32->Get32();

		/* output leading 0 */
		if(!(Event = NewEvent(Target)))
			return true;

		Event->Type = TE_BIT;
		Event->Data.Bit.Data32 = Event->Data.Bit.Data8 = 0;

		/* output bits */
		int ic = 8;
		while(ic--)
		{
			if(!(Event = NewEvent(Target)))
				return true;

			Event->Type = TE_BIT;
			Event->Data.Bit.Data32 = Data32&0xf; Data32 >>= 4;
			Event->Data.Bit.Data8 = Data8&1; Data8 >>= 1;
		}

		/* output trailing 1 */
		if(!(Event = NewEvent(Target)))
			return true;

		Event->Type = TE_BIT;
		Event->Data.Bit.Data32 = 0xf;
		Event->Data.Bit.Data8 = 1;
	}

	CorrectTime(Event);

	return false;
}
Uint32 CUEFTapeImplicitData::GetLength()
{
	return (Uint32)((float)DChunk8->GetLength() * (20000000.0f / BaudRate));
}

/*

	EXPLICIT DATA (&0102, possibly feat &0101/3)

*/
class CUEFTapeExplicitData: public CUEFTapeChunk
{
	public:
		CUEFTapeExplicitData(CUEFChunkSelector *a, float b, Uint16 c) { Setup(a, b, c, true); }
		Uint32 GetLength();
		bool Initialise();
		bool WriteEvents(TapeEventQueueUEF &);

	private:
		Uint32 NumBits;
};
bool CUEFTapeExplicitData::Initialise()
{
	Uint8 EMask = DChunk8->GetC();
	NumBits = DChunk8->GetLength() << 3;
	if(EMask >= NumBits) return false;
	NumBits -= EMask;

	return true;
}
bool CUEFTapeExplicitData::WriteEvents(TapeEventQueueUEF &Target)
{
	Uint8 Data8 = 0;
	Uint32 Data32 = 0;
	TapeEvent *Event = NULL;

	for(Uint32 BitCount = 0; BitCount < NumBits; BitCount++)
	{
		if(!(BitCount&7))
		{
			Data8 = DChunk8->GetC();
			if(DChunk32) Data32 = DChunk32->Get32();
		}

		/* output bit */
		if(!(Event = NewEvent(Target)))
			return true;

		Event->Type = TE_BIT;
		Event->Data.Bit.Data32 = Data32&0xf; Data32 >>= 4;
		Event->Data.Bit.Data8 = Data8&1; Data8 >>= 1;
	}

	CorrectTime(Event);

	return false;
}
Uint32 CUEFTapeExplicitData::GetLength()
{
	return (Uint32)((float)NumBits * (2000000.0f / BaudRate));
}

/*

	DEFINED DATA (&0104, possibly feat &0101/3)

*/
class CUEFTapeDefinedData: public CUEFTapeChunk
{
	public:
		CUEFTapeDefinedData(CUEFChunkSelector *a, float b, Uint16 c) { Setup(a, b, c, true); }
		Uint32 GetLength();
		bool WriteEvents(TapeEventQueueUEF &);
		bool Initialise();

	private:
		Uint8 DataBits;

		bool WithParity;
		Uint8 ParityMask;
		Uint16 StopWaves;
};

bool CUEFTapeDefinedData::Initialise()
{
	DataBits = DChunk8->GetC();
	if(DataBits > 8) return false;

	switch(DChunk8->GetC())
	{
		default: return false;
		case 'N':
			WithParity = false;
		break;
		case 'O':
			WithParity = true;
			ParityMask = 1;
		break;
		case 'E':
			WithParity = true;
			ParityMask = 0;
		break;
	}

	Sint8 Stops = DChunk8->GetC();
	if(Stops > 0)
		StopWaves = (Uint16)Stops << 1;
	else
		StopWaves = -Stops;

	return true;
}
bool CUEFTapeDefinedData::WriteEvents(TapeEventQueueUEF &Target)
{
	TapeEvent *Event = NULL;

	while(!DChunk8->EOC())
	{
		/* output leading 0 */
		if(!(Event = NewEvent(Target)))
			return true;

		Event->Type = TE_BIT;
		Event->Data.Bit.Data32 = Event->Data.Bit.Data8 = 0;

		/* output bits */
		Uint8 Data8;
		Uint32 Data32 = 0;

		Data8 = DChunk8->GetC();
		if(DChunk32) Data32 = DChunk32->Get32();

		Uint8 ParityValue = Data8 ^ (Data8 >> 4);
		ParityValue ^= ParityValue >> 2;
		ParityValue ^= (ParityValue >> 1) ^ ParityMask;

		int ic = DataBits;
		while(ic--)
		{
			if(!(Event = NewEvent(Target)))
				return true;

			Event->Type = TE_BIT;
			Event->Data.Bit.Data32 = Data32&0xf; Data32 >>= 4;
			Event->Data.Bit.Data8 = Data8&1; Data8 >>= 1;
		}

		/* output parity */
		if(WithParity)
		{
			if(!(Event = NewEvent(Target)))
				return true;

			Event->Type = TE_BIT;
			Event->Data.Bit.Data32 = 0;
			Event->Data.Bit.Data8 = ParityValue&1;
		}

		/* output stop bits */
		int SBCount = StopWaves >> 1;
		while(SBCount--)
		{
			if(!(Event = NewEvent(Target)))
				return true;

			Event->Type = TE_BIT;
			Event->Data.Bit.Data32 = 0xf;
			Event->Data.Bit.Data8 = 1;
		}

		if(StopWaves&1)
		{
			if(!(Event = NewEvent(Target, 1)))
				return true;
			Event->Type = TE_WAVE;
		}
	}

	CorrectTime(Event);

	return false;
}
Uint32 CUEFTapeDefinedData::GetLength()
{
	return (Uint32)(
		(float)(DChunk8->GetLength()-3)*
			(
				2*(DataBits+1+ (WithParity? 1 : 0)) +
				StopWaves
			)
		* (1000000.0f / BaudRate));
}

/*

	SECURITY WAVES (&0114)

*/
class CUEFTapeSecurity: public CUEFTapeChunk
{
	public:
		CUEFTapeSecurity(CUEFChunkSelector *a, float b, Uint16 c) { Setup(a, b, c); }
		Uint32 GetLength();
		bool Initialise();
		bool WriteEvents(TapeEventQueueUEF &);

	private:
		Uint32 NumWaves;
		bool StartHalf, EndHalf;
		Uint32 Length;
};

bool CUEFTapeSecurity::Initialise()
{
	if(DChunk8->GetLength() < 6) return false;

	NumWaves = DChunk8->Get16();
	NumWaves |= DChunk8->GetC() << 16;

	if((NumWaves >> 3) > (DChunk8->GetLength()-5))
		return false;

	switch(DChunk8->GetC())
	{
		case 'P': StartHalf = true; break;
		case 'W': StartHalf = false; break;
		default: return false;
	}

	switch(DChunk8->GetC())
	{
		case 'P': EndHalf = true; break;
		case 'W': EndHalf = false; break;
		default: return false;
	}

	return true;
}
bool CUEFTapeSecurity::WriteEvents(TapeEventQueueUEF &Target)
{
	DChunk8->ReadSeek(5, SEEK_SET);

	Uint32 Data = DChunk8->Get32();
	int DataCounter = 32;
	Uint32 WaveCount = 0;
	TapeEvent *Event = NULL;

	if(StartHalf)
	{
		if(!(Event = NewEvent(Target, 1+(Data&1))))
			return true;

		Event->Type = TE_PULSE;
		Event->Data.Pulse.High = true;
		Data >>= 1;
		DataCounter--;
		WaveCount++;
	}

	while(
		(!EndHalf && (WaveCount < NumWaves)) ||
		(EndHalf && (WaveCount < (NumWaves-1)))
	)
	{
		if(!(Event = NewEvent(Target, (Data&1))))
			return true;

		Event->Type = TE_WAVE;
		Data >>= 1;
		DataCounter--;
		WaveCount++;

		if(!DataCounter)
		{
			Data = DChunk8->Get32();
			DataCounter = 32;
		}
	}

	if(EndHalf)
	{
		if(!(Event = NewEvent(Target, 1+(Data&1))))
			return true;

		Event->Type = TE_PULSE;
		Event->Data.Pulse.High = false;
		Data >>= 1;
		DataCounter--;
		WaveCount++;
	}

	CorrectTime(Event);

	return false;
}
Uint32 CUEFTapeSecurity::GetLength()
{
	Uint32 Length = 0;

	DChunk8->ReadSeek(5, SEEK_SET);

	Uint32 Data = DChunk8->Get32();
	int DataCounter = 32;
	Uint32 WaveCount = 0;

	if(StartHalf)
	{
		Length++;
		Data >>= 1;
		DataCounter--;
		WaveCount++;
	}

	while(
		(!EndHalf && (WaveCount < NumWaves)) ||
		(EndHalf && (WaveCount < (NumWaves-1)))
	)
	{
		Length += (Data&1) ? 2 : 4;
		Data >>= 1;
		DataCounter--;
		WaveCount++;
		if(!DataCounter)
		{
			Data = DChunk8->Get32();
			DataCounter = 32;
		}
	}

	if(EndHalf)
	{
		Length++;
	}

	return (Uint32)((float)Length*(500000.0f / BaudRate));
}

/*

	CLASS PROPER
*/
bool TapeEventQueueUEF::Open(char *name)
{
	if(TSelector = GetHost() -> GetUEFSelector(name, UEF_VERSION))
	{
		BaudRate = 1200;
		Phase = 180;

		/* make sure at least one chunk makes sense */
		TSelector->ResetOverRan();
		bool FoundSomething = false;
		while(!FoundSomething)
		{
			if(TSelector->OverRan())
			{
				GetHost() -> ReleaseUEFSelector(TSelector);
				TSelector = NULL;
				return false;
			}

			TSelector->FindIdMajor(0x01);
			switch(TSelector->CurrentChunk()->GetId())
			{
				default: break;
				case BAUDWISE_GAP:
				case FLOATING_GAP:
				case HTONE:
				case HTONEDUMMY:
				case IMPLICIT_DATA:
				case EXPLICIT_DATA:
				case SECURITY:
				case DEFINED_DATA:
					FoundSomething = true;
				break;
			}
		}

		TSelector->ResetOverRan();
		TSelector->Reset();
		return true;
	}

	return false;
}

void TapeEventQueueUEF::Close()
{
	if(CSource)
	{
		delete CSource;
		CSource = NULL;
	}
	if(TSelector)
	{
		GetHost() -> ReleaseUEFSelector(TSelector);
		TSelector = NULL;
	}
}

void TapeEventQueueUEF::Flush(Uint64)
{
}

Uint32 TapeEventQueueUEF::GetFlags()
{
	return 0;
}

void TapeEventQueueUEF::GetNewFeeder()
{
	if(CSource)
	{
		delete CSource;
		CSource = NULL;
	}

	while(!CSource)
	{
		TSelector->Seek(1, SEEK_CUR);

#ifdef DUMP_CHUNKS
		printf("Chunk %04x\n", TSelector->CurrentChunk()->GetId());
#endif
		Uint16 id = TSelector->CurrentChunk()->GetId();
		switch(id)
		{
			case BAUDWISE_GAP:
			case FLOATING_GAP:
				CSource = new CUEFTapeGap(TSelector, BaudRate, Phase);
			break;

			case HTONE:
				CSource = new CUEFTapeHTone(TSelector, BaudRate, Phase);
			break;
			case HTONEDUMMY:
				CSource = new CUEFTapeHToneDummy(TSelector, BaudRate, Phase);
			break;

			case IMPLICIT_DATA:
				CSource = new CUEFTapeImplicitData(TSelector, BaudRate, Phase);
			break;
			case EXPLICIT_DATA:
				CSource = new CUEFTapeExplicitData(TSelector, BaudRate, Phase);
			break;
			case SECURITY:
				CSource = new CUEFTapeSecurity(TSelector, BaudRate, Phase);
			break;
			case DEFINED_DATA:
				CSource = new CUEFTapeDefinedData(TSelector, BaudRate, Phase);
			break;

			case PHASE_CHANGE:	Phase = TSelector->CurrentChunk()->Get16();			break;
			case BAUD_RATE:		BaudRate = TSelector->CurrentChunk()->GetFloat();	break;

			default:
				/* inline snapshot? */
//				{
//					int i = 2;
//				}
/*				if((id >> 8) == 0x4)
					CSource = new CUEFChunkFeederSnapshot(TSelector, BaudRate, Phase);*/
			break;
		}

		if(CSource)
			if(!CSource->Initialise())
			{
				delete CSource;
				CSource = NULL;
			}
	}
}

void TapeEventQueueUEF::GenerateEvents(Uint64 WantTime)
{
	/* linear search from start or last chunk if later*/
	Uint64 STime = 0;

	TSelector->Reset();
	TSelector->ResetOverRan();

	if((WantTime >= LastFoundTime) && LastFoundTime)
	{
		STime = LastFoundTime;
		TSelector->Seek(LastChunk-1, SEEK_SET);
	}
	LastWantTime = WantTime;

	Uint32 ChunkLength;
	while(!TSelector->OverRan())
	{
		GetNewFeeder();
		ChunkLength = CSource->GetLength();

		if((ChunkLength + STime) > WantTime)
			break;
		STime += ChunkLength;
	}

	SeedEventList(LastFoundTime = STime);
	LastChunk = TSelector->GetOffset();

	/* great, now get feeding! */
	while(!TSelector->OverRan() && !CSource->WriteEvents(*this))
		GetNewFeeder();

	if(TSelector->OverRan())
	{
		TapeEvent *NewEvent;
		if(NewEvent = GetNewEvent())
		{
			NewEvent->Type = TE_END;
			NewEvent->BaudRate = BaudRate;
			NewEvent->Length = 0;
			NewEvent->Phase = Phase;
		}
	}
}

Uint64 TapeEventQueueUEF::GetLength()
{
	TSelector->Reset();
	TSelector->ResetOverRan();
	Uint64 Length = 0;

	while(1)
	{
		GetNewFeeder();
		if(TSelector->OverRan())
			break;
		Length += CSource->GetLength();
	}

	return Length;
}

TapeEventQueueUEF::~TapeEventQueueUEF()
{
	Close();
}

TapeEventQueueUEF::TapeEventQueueUEF()
{
	CSource = NULL;
	LastChunk = 0;
	LastWantTime = LastFoundTime = 0;
}

#define		TITLE	0x0009
#define		CREATOR	0x0000

char *TapeEventQueueUEF::GetTitle()
{
	if(TSelector->FindId(TITLE))
		return TSelector->CurrentChunk()->GetString();

	return NULL;
}

char *TapeEventQueueUEF::GetCreator()
{
	if(TSelector->FindId(CREATOR))
		return TSelector->CurrentChunk()->GetString();

	return NULL;
}
